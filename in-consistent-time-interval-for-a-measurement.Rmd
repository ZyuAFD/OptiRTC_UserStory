## Story 1: Inconsistent time intervals for individual data streams

The OptiRTC data is collect on real time. The inconsistent interval of the logged data makes it difficult to import the data into some software application or analysis software without significant manipulating and reanalysis. Code is needed that normalizes the time interval of the data streams to user-specified values. 

#### Loading Sample Data
```{r message=F,warning=F}
# code from https://tonybreyal.wordpress.com/2011/11/24/source_https-sourcing-an-r-script-from-github/
# for loading github code without SSL verification
source_https <- function(url, ...) {
  # load package
  require(RCurl)
 
  # parse and evaluate each .R script
  sapply(c(url, ...), function(u) {
    eval(parse(text = getURL(u, followlocation = TRUE, cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl"))), envir = .GlobalEnv)
  })
}


source_https("https://raw.githubusercontent.com/OptiRTC/export-analysis/ZyuAFD-patch-1/Data/Loading%20Sample%20Data.R?token=AKLn5qDAj4bxtrQ6mDc1_JLrD910hcKUks5aXjcTwA%3D%3D")
```

#### This code is a sample of aggregation of rain gauge data on Golda Meir data. 

- The data quality is first checked of the duplicated time step for rain data

```{r Check data quality on duplicated steps,message=F,warning=F}

# Extract Rain information for analysis
Rain_dt=GoldaMeir_Dt %>% select(Time,Inst_Rain) %>% filter(!is.na(Inst_Rain))

Rain_dt %>% head(10)%>% kable

# Check duplicate time step

Rain_dt %>% 
    group_by(Time) %>% 
    tally %>% 
    filter(n>1) %>% 
    arrange(-n)
```


- Time steps are then rounded up to a time interval value of 5 minutes ( This string has to be among the built-in strings for "unit" parameter in [lubridate::round_date](https://github.com/tidyverse/lubridate/blob/master/R/round.r) function). In this case, [lubridate::floordate](https://github.com/tidyverse/lubridate/blob/master/R/round.r) is used since rain gauge data is a cumulative value aggregated down to its nearest round time point.
- Check the duplicated time interval and aggregate the rain data upon it

```{r Aggregation on rain data in specified time interval,message=F,warning=F}

Time_Intv= "hour" # constant of time interval in lubridate::round_date function
# Round time into specified time interval
Rain_dt %<>% 
    mutate(Time_rnd=lubridate::floor_date(Time,Time_Intv))

Rain_dt %>% head%>% kable

# Check duplicate time on rounded time 
Rain_dt %>% 
    group_by(Time_rnd) %>% 
    tally %>% 
    filter(n>1) %>% 
    arrange(-n) 

# Aggregate the rain amount 
Rain_dt %<>% 
    group_by(Time_rnd) %>% 
    summarise(Inst_Rain=sum(Inst_Rain))

Rain_dt %>% head(10)%>% kable

```

- Check the data gaps in the aggregated data

```{r}

FindGaps=function(Dt,Tm_intv)
    #Dt dataframe with time column
    #Tm_intv: min gap, use time interval here
{
    Dt %>% 
        arrange(Time) %>% 
        mutate(lagT=lag(Time)) %>% 
        filter(as.period(interval(lagT,Time))>period(Tm_intv))->gaps
    
    if (nrow(gaps)==0) return("No Gaps")
    
    gaps %>% 
        mutate(Time_interval=interval(lagT,Time)) %>% 
        select(Time_interval) %>% 
        mutate(Period=as.period(Time_interval)) %>% 
        return
}

Rain_dt %>% 
    rename(Time=Time_rnd) %>% 
    FindGaps(Tm_intv=Time_Intv) %>% 
    kable

```






